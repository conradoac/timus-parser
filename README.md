## Introduction

The main purpose of Timus Parser is to analyze programming languages with the same syntactic characteristics as JavaScript, but with different words. Consider the following code snippet, written in JavaScript:

```javascript
function factorial(n) {
    if (n === 0)
        return 1;
    return n * factorial(n - 1);
}
```

Now see the same piece of code written in Lume, the corresponding version of JavaScript that uses Portuguese words.

```lume
funÃ§Ã£o fatorial(n) {
    se (n === 0)
        retornar 1;
    retornar n * fatorial(n - 1);
}
```

Note that the same JavaScript rules are valid, but with different keywords.

Also note that we have chosen to change the identifier "factorial" to "fatorial", which is how the word is written in Portuguese. However, the choice of identifier name is and will remain with the developer. We did this only to maintain consistency with language changes.

Other variations could be created, using terms in other languages - Spanish, for example - or at the discretion of those who are creating the "new" language:

```
fn fact(n) {
    if (n === 0)
        rtn 1;
    rtn n * fact(n - 1);
}
```

Remember that any UNICODE character can be used. See a short excerpt written in Happy, a language that uses emotions as synonyms for some words:

```happy
ðŸ˜´ fn lazy(value) {
  ðŸ¤” (value < 1)
    ðŸ‘‰ 10;
  ðŸ‘‰ 20;
}
```

The result generated by the parser is a tree data structure. This structure is known as AST (abstract syntax tree). Below is a small excerpt of the AST generated for the JavaScript code given as an example above:

```json
{
  "type": "Program",
  "start": 0,
  "end": 93,
  "body": [
    {
      "type": "FunctionDeclaration",
      "start": 0,
      "end": 93,
      "id": {
        "type": "Identifier",
        "start": 9,
        "end": 18,
        "name": "factorial"
      },
      "expression": false,
      "generator": false,
      "async": false,
      "params": [
        {
          "type": "Identifier",
          "start": 19,
          "end": 20,
          "name": "n"
        }
      ],
      "body": {
          ...
      }
    }
  ],
  "sourceType": "module"
}
```

The purpose of Timus Parser is to generate the same structure as a result for any of the language variations. The only differences are in the beginning and end fields of each node in the tree, because of the variations in the length of the words. This is important for the structure to be a real representation of the analyzed source code.

## Creating a new language

To create a new language you only need to define a configurator object that reports the respective words of the language.

```json
{
  "function": "fn",
  "let": "seja"
}
```

You can also define more than one option for the same word:

```json
{
  "function": "fn",
  "let": "seja",
  "new": "novo | nova"
}
```

The absence of a word in the configurator object is not a problem. The parser will complete the translations with the rest of the JavaScript words.

It is just not allowed to use the same word as a synonym for different JavaScript keywords. In this case we would have a problem ...

## API

### Creating a Timus Parser

A new parser can be created as follows:

```javascript
const parser = new TimusParser(code, options);
```

Where `code` is the source code that will be evaluated by the parser and` options` is an object with options for the parser.

Since Timus Parser is an extension of Acorn, the same options as Acorn are valid here.

### Defining the language

You must tell the parser what language it will work for by inserting a `language` property in the` options` object. The value of this property must be the language's configurator object.

```javascript
const options = {
  language: {
    function: "fn"
  }
};

const code = "fn foo() { }";

const parser = new TimusParser(code, options);
```

If the `language` property is not entered, the parser will understand that the code to be analyzed was written in JavaScript.

### Getting the current parser language

To get the language configured for the parser, you can use the `getLanguage` method, as shown below:

```javascript
const options = {
  language: {
    function: "fn"
  }
};

const code = "fn foo() { }";

const parser = new TimusParser(code, options);

const language = parser.getLanguage();
// { function: "fn" }
```

### Analyzing a code

To start the code analysis process, you must call the `parse` method. This method returns an AST (abstract syntax tree).

```javascript
const options = {
  language: {
    function: "fn"
  }
};

const code = "fn foo() { }";

const parser = new TimusParser(code, options);

const ast = parser.parse();
// { type: "Program" ... }
```

### Utilities

Some methods are interesting and quite useful in some situations:

1. `getLanguageSynonyms(jsWord)`: gets a list of the synonymous words for the respective JavaScript word. If a language has not been specified, or the synonym definitions for `jsWord` are not found, a list containing the word itself as an element will be returned.

```javascript
const options = {
  language: {
    function: "fn",
    new: "novo | nova"
  }
};

const code = "fn foo() { }";

const parser = new TimusParser(code, options);

parser.getLanguageSynonyms("function"); // ["fn"]
parser.getLanguageSynonyms("new"); // ["novo", "nova"]
parser.getLanguageSynonym("async"); // ["async"]
```


2. `getLanguageSynonym(jsWord, alt)`: gets the synonym for the respective JavaScript word in the current language. `alt` is an optional number, which specifies which alternative should be returned, in cases where more than one option is provided in the language configurator object. If a language has not been specified, or if no alternative has been entered in the configurator object, the JavaScript word itself passed as an argument will be returned.

```javascript
const options = {
  language: {
    function: "fn",
    new: "novo | nova"
  }
};

const code = "fn foo() { }";

const parser = new TimusParser(code, options);

parser.getLanguageSynonym("function"); // "fn"
parser.getLanguageSynonym("new"); // "novo"
parser.getLanguageSynonym("new", 0); // "novo"
parser.getLanguageSynonym("new", 1); // "nova"
parser.getLanguageSynonym("async"); // "async"
```

3. `getJavaScriptSynonym(langWord)`: get the value of a word in JavaScript, from the respective word in the current language.

```javascript
const options = {
  language: {
    function: "fn",
    new: "novo | nova"
  }
};

const code = "fn foo() { }";

const parser = new TimusParser(code, options);

parser.getJavaScriptSynonym("fn"); // "function"
parser.getJavaScriptSynonym("novo"); // "new"
parser.getJavaScriptSynonym("nova"); // "new"
parser.getJavaScriptSynonym("xxx"); // undefined
```

3. `areSynonyms(langWord, jsWord)`: Checks whether a given word in the current language (`langWord`) is synonymous with the word` jsWord` in JavaScript.

```javascript
const options = {
  language: {
    function: "fn",
    new: "novo | nova"
  }
};

const code = "fn foo() { }";

const parser = new TimusParser(code, options);

parser.areSynonyms("fn", "function"); // true
parser.areSynonyms("novo", "new"); // true
parser.areSynonyms("nova", "new"); // true
parser.areSynonyms("fn", "new"); // false
```